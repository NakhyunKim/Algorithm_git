		Divide & Conquer
-주어진 문제를 둘 이상의 부분 문제로 나눈 뒤 각 문제에 대한 답을 재귀
호출을 이용해 계산하고, 각 부분 문제의 답으로부터 전체 문제의 답을 계산

-분할 정복의 세가지 구성 요소
 1. 문제를 더 작은 문제로 분할하는 과정(divide)
 2. 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정(merge)
 3. 더이상 답을 분할하지 않고 곧장 풀 수있는 매우 작은 문제(base case)

-분할 정복을 하기 위한 특성
 1. 문제를 둘 이상의 부분 문제로 나누는 자연스러운 방법 존재
 2. 부분 문제의 답을 조합해 원래 문제의 답을 계산하는 효율적인 방법 존재

ex)수열의 빠른 합
문제 : 1 부터 n까지의 합

fastSum() = 1 + 2 + ... + n
          = (1 + 2 + ... + n/2) + ((n/2+1) + ... + n)

-첫 번째 부분 문제는 fastSum(n/2)로 표현 가능
-두 번째 부분은 '1부터 n까지의 합' 꼴로 바꿔줘야함

(n/2 + 1) + (n/2 + 2) + (n/2 + 3) + ... + (n/2 + n/2)
= n/2 * n/2 + (1 + 2 + 3 + ... + n/2)

따라서 fastSum(n) = fastSum(n/2) + n/2*n/2 + fastSum(n/2)
				  = 2*fastSum(n/2)+n^2/4 (n이 짝수일때)
-n이 짝수 일때만 동작한다. 따라서 홀 수 일때도 고려
-홀수 일때  = fastSum(n-1) + n

따라서 
//필수 조건:n은 자연수
//1+2+3...+n을 반환한다.
int fastSum(int n) {
	//기저사례
	if(n==1) return 1;
	if(n % 2 == 1) return fastSum(n-1) + n;
	return 2*fastSum(n/2) + (n/2)*(n/2);
}
